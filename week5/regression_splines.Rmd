---
title: "regression_splines"
author: "Alejandro Pimentel"
date: "2022-09-29"
output:
  html_document: 
    theme: readable
    toc: yes
    toc_float: TRUE
    code_folding: show
    code_download: true
  pdf_document: default
urlcolor: cyan
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Spline Basis Functions

Basis functions for cubic splines with 5 knots and df = 9.

```{r}
x = (1:199)/100;
n = length(x)
m = 5;
# each knot is on a quantile, 
# where the range of x is 0.01 to 1.99
myknots = 2*(1:m)/(m+1)
myknots
```

The solid lines are the 4 cubic polynomials, and the dashed ones are the truncated power basis.

The dots are the knots, note how each power basis line is 0 to the left of the corresponding knot.

```{r}
X = cbind(1, x, x^2, x^3);
for(i in 1:m){
    # for each knot we create a basis function.
    # we substract each knot from x, the actual value of predictor p.
    tmp = (x-myknots[i])^3;
    # to the left knot is 0, to the right, it takes a cubic form.
    tmp[tmp<0] = 0;
    # we add the basis function to
    # the design matrix
    X = cbind(X, tmp);
    }
plot(c(0,2), range(X), type="n", xlab="", ylab="")
title("Truncated Power Basis")

for(i in 1:(m+4)){
    tmp = X[,i];
    if (i<=4) mylty=1 else mylty=2;
    lines(x[tmp!=0], tmp[tmp!=0], col=i, lty=mylty, lwd=2)
    }
for(i in 1:m){
    points(myknots[i], 0, pty="m", pch=19, cex=2)
  }
```

Here will have 9 cols, df=9, since we set intercept to true.

```{r}
F = bs(x,knots = myknots, intercept = TRUE)
dim(F)
```

```{r}
mydf = m+4; 
tmpdata = data.frame(t = rep(1:n, mydf),
                     basisfunc=as.vector(F), 
                     type=as.factor(rep(1:mydf, each=n)))
ggplot(tmpdata, aes(x=t, y=basisfunc, color=type)) + 
  geom_path()
```

If we do not set intercept = TRUE, then bs will return 9-1 = 8 columns.

```{r}
F = bs(x, knots = myknots)
dim(F)
mydf = m+3; 
tmpdata = data.frame(t = rep(1:n, mydf),
                     basisfunc=as.vector(F), 
                     type=as.factor(rep(1:mydf, each=n)))
ggplot(tmpdata, aes(x=t, y=basisfunc, color=type)) +
  geom_path()
```

Basis functions for NCS with 7 knots (5 interior knots and 2 boundary knots) and df = 7

```{r}
# We can specify points a and b, which are around
# the extremes of x
F = ns(x, knots=myknots, Boundary.knots=c(0,2), intercept=TRUE)
dim(F)
```

```{r}
mydf = 7
tmpdata = data.frame(t = rep(1:n, mydf),
                     basisfunc=as.vector(F), 
                     type=as.factor(rep(1:mydf, each=n)))
ggplot(tmpdata, aes(x=t, y=basisfunc, color=type)) +
  geom_path()
```


## The Birthrates Data

This dataset lists the number of live births per 10,000 23-year-old women in the United States between 1917 and 2003.

```{r}
source("birthrates.txt");
birthrates = as.data.frame(birthrates)
names(birthrates) = c("year", "rate")
ggplot(birthrates, aes(x=year, y=rate)) + 
  geom_point() + geom_smooth(method="lm", se=FALSE)
```

Understand how R counts the df.

```{r}
# 2 knots + each power of x, no intercept, df = 5 + 1 ??
# F-statistic: 45.17 on 5 and 81 DF
fit1 = lm(rate~bs(year, knots=quantile(year, c(1/3, 2/3))),
          data=birthrates);
# knots=5-3, since intercept is not counted (3 because x,x^2,x^3)
fit2 = lm(rate~bs(year, df=5), data=birthrates);
# knots=6-4, we count the intercept here, (4 because 1,x,x^2,x^3)
fit3 = lm(rate~bs(year, df=6, intercept=TRUE), data=birthrates) 
# fit 1 to 3 are all the same

# knots=5-4, so only 1 knot on this one.
fit4 = lm(rate~bs(year, df=5, intercept=TRUE), data=birthrates)

plot(birthrates$year, birthrates$rate, ylim=c(90,280))
lines(spline(birthrates$year, predict(fit1)), col="red", lty=1)
lines(spline(birthrates$year, predict(fit2)), col="blue", lty=2)
lines(spline(birthrates$year, predict(fit3)), col="green", lty=3)
lines(spline(birthrates$year, predict(fit4)), lty=2, lwd=2)
```

```{r}
# Alternatively, you can predict the spline fit on a fine grid, and then connect them

plot(birthrates$year, birthrates$rate, ylim=c(90,280))
year.grid = seq(from=min(birthrates$year), to=max(birthrates$year), length=200)
ypred = predict(fit4, data.frame(year=year.grid))
lines(year.grid, ypred, col="blue", lwd=2)
```


```{r}

# for ns, df=interior knots + 2 = 6, the F matrix will have 5 cols
fit1=lm(rate~ns(year, knots=quantile(year, (1:4)/5)), data=birthrates);
# knots=df-2+1 = 4, df=5+1, the F matrix will have 5 cols
fit2=lm(rate~ns(year, df=5), data=birthrates);
# df=6, knots=6-2 (2 here are the boundary knots), the F matrix will have 6 cols
fit3=lm(rate~ns(year, df=6, intercept=TRUE), data=birthrates) 

plot(birthrates$year, birthrates$rate, ylim=c(90,280))
lines(spline(birthrates$year, predict(fit1)), col="red", lty=1)
lines(spline(birthrates$year, predict(fit2)), col="blue", lty=2)
lines(spline(birthrates$year, predict(fit3)), col="green", lty=3)
```

Try cubic splines with different degree-of-freedoms

The more degrees of freedom the more the model fits the training data.

```{r}
plot(birthrates$year, birthrates$rate, ylim=c(90,280));
lines(spline(birthrates$year, predict(lm(rate~bs(year, df=7), data=birthrates))), col="blue");
lines(spline(birthrates$year, predict(lm(rate~bs(year, df=14), data=birthrates))), col="red");
lines(spline(birthrates$year, predict(lm(rate~bs(year, df=19), data=birthrates))), col="black");
legend("topright", lty=rep(1,3), col=c("blue", "red", "black"), legend=c("df=8", "df=15", "df=20"))
```

Make prediction outside the data range

```{r}
new = data.frame(year=1905:2015);
fit1=lm(rate~bs(year, df=7), data=birthrates);
pred1=predict(fit1, new);
```

CS cubic spline at the extremes continues as a cubic function.
NCS on the other hand continues linearly in the direction of the last derivative...

```{r}
fit2=lm(rate~ns(year, df=7), data=birthrates);
pred2=predict(fit2, new);
plot(birthrates$year,birthrates$rate, xlim=c(1905,2015),
     ylim=c(min(pred1,pred2), max(pred1,pred2)), 
     ylab="Birth Rate", xlab="Year") 
lines(new$year, pred1, col="red")
lines(new$year, pred2, col="blue")
legend("bottomleft", lty=rep(1,2),  col=c("red",  "blue" ), legend=c("CS with df=7", "NCS with df=7"))
```

Use 10-fold CV to select df (or equivalently the number of knots)

The location of knots will affect the performance of a spline model. But selecting the location of knots is computationally too expensive. Instead, we place knots equally at quantiles of x, and then select just the number of knots, or equivalently, the df. Can we use F-test to select the number of knots?

For each df, we use 10-fold CV to calculate the CV error. When doing 10-fold CV, each time, based on 90% of the data, we place the (df-4) knots at the corresponding quantiles and then fit a regression spline,

First, we need to divide the data into K folds.

```{r}
K=10
n = nrow(birthrates)
fold.size = c(rep(9, 7), rep(8, 3))
fold.id = rep(1:K, fold.size)
fold.id
```

```{r}
fold.id = fold.id[sample(1:n, n)]
fold.id
```

```{r}
mydf = 10:30
mycv = rep(0, length(mydf))

for(i in 1:length(mydf)){
  m = mydf[i]-4;  
  for(k in 1:K){
    id = which(fold.id == k);
    myknots = quantile(birthrates$year[-id], (1:m)/(m+1))
    myfit = lm(rate ~ bs(year, knots=myknots),
               data=birthrates[-id,])
    ypred = predict(myfit, newdata=birthrates[id,])
    mycv[i]=mycv[i] + sum((birthrates$rate[id] - ypred)^2)
  }
}
plot(mydf, mycv)
```

Re-run the 10-fold CV. The plot of mydf versus mycv may vary, but shouldnâ€™t be too different.

```{r}
fold.id = rep(1:K, fold.size)
fold.id = fold.id[sample(1:n, n)]

mydf = 10:30
mycv = rep(0, length(mydf))

for(i in 1:length(mydf)){
  m = mydf[i]-4;  
  for(k in 1:K){
    id = which(fold.id == k);
    myknots = quantile(birthrates$year[-id], (1:m)/(m+1))
    myfit = lm(rate ~ bs(year, knots=myknots),
               data=birthrates[-id,])
    ypred = predict(myfit, newdata=birthrates[id,])
    mycv[i]=mycv[i] + sum((birthrates$rate[id] - ypred)^2)
  }
}
plot(mydf, mycv)
```

